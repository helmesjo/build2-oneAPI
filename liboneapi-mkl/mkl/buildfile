intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

# --- Common config -------------------------------------------------

name = $string.replace($project, 'liboneapi-', '')
mkl.version        = 2025.2.0
mkl.short_version  = 2025.2
# Full MKL version with + as in the manifests/ids.
mkl.version_full = 2025.3.0+453
# Intelâ€™s repo uses %2B for '+' in the URL.
mkl.version_url = $string.replace($mkl.version_full, '+', '%2B')

mkl.class = $cc.target.class        # 'windows', 'linux'
mkl.cpu   = $cc.target.cpu          # 'x86_64'

# Only x86_64 Windows/Linux like the vcpkg port.
if (!($mkl.cpu == 'x86_64' && ($mkl.class == 'windows' || $mkl.class == 'linux')))
  fail "intel-mkl: only windows/linux x86_64 supported"

mkl.package_infix  = ($mkl.class == 'windows' ? 'win' : 'lin')
mkl.runtime_dir    = ($mkl.class == 'windows' ? 'bin' : 'lib')

# vcpkg URLs / filenames / SHA512, verbatim.
print $mkl.class
if ($mkl.class == 'windows')
{
  mkl.filename = 'intel-onemkl-2025.2.0.630_offline.exe'
  mkl.magic    = '307bccae-8631-4712-8999-02a8abf51994'
  mkl.sha512   = '13d6c1ab943d2a3a16ee29be995215ef14eb469215c24633d9fdff1f0e1b3e78225ed92780b9a20d90812160da5a4969e16f0e9df36df45389c4fab4b5ecac3d'
  mkl.ext      = '.exe'
}
else
{
  mkl.filename = 'intel-onemkl-2025.2.0.629_offline.sh'
  mkl.magic    = '47c7d946-fca1-441a-b0df-b094e3f045ea'
  mkl.sha512   = '60e0b86b2e63da1becb527db0d912d19e2a664671e1e6cf54ac6fad35ced3bb791e490d4b7d1a555231a0b553a32652d1c6c41869222c88f30e17fee5c436cd3'
  mkl.ext      = '.sh'
}

mkl.url      = "https://registrationcenter-download.intel.com/akdlm/IRC_NAS/$mkl.magic/$mkl.filename"
mkl.archive  = "$out_root/$mkl.class-$mkl.cpu-$mkl.version-archive$mkl.ext"

mkl.extract_0 = "$out_root/$mkl.class-$mkl.cpu-$mkl.version-extract-0"
mkl.extract_1 = "$out_root/$mkl.class-$mkl.cpu-$mkl.version-extract-1"

# Final JSON URL:
#   https://installer.repos.intel.com/oneapi/mkl/win/intel.oneapi.win.onemkl.content,v=2025.3.0%2B453.json
mkl.json = "https://installer.repos.intel.com/oneapi/mkl/$(mkl.package_infix)/intel.oneapi.$(mkl.package_infix).onemkl.content,v=$(mkl.version_url).json"

# Where you want the final, flattened MKL layout.
mkl.root = $out_base                 # -> $out_base/include, lib, bin, compiler
text "mkl.filename          $mkl.filename"
text mkl.json              $mkl.json
text "mkl.magic             $mkl.magic"
text "mkl.sha512            $mkl.sha512"
text "mkl.ext               $mkl.ext"
text "mkl.dir               $mkl.dir"
text "mkl.version           $mkl.version"
text "mkl.package_infix     $mkl.package_infix"
text "mkl.archive           $mkl.archive"
text "mkl.extract_0         $mkl.extract_0"
text "mkl.extract_1         $mkl.extract_1"
text "mkl.component_prefix  $mkl.component_prefix"
text "mkl.component.runtime $mkl.component.runtime"
text "mkl.component.devel   $mkl.component.devel"
text "mkl.component.openmp  $mkl.component.openmp"
text "mkl.components        $mkl.components"
text "mkl.install_prog      $mkl.install_prog"
# text "mkl.install_args      $mkl.install_args"
# text "mkl.install_prog      $mkl.install_prog"
# text "mkl.install_args      $mkl.install_args"

# --- Download target -----------------------------------------------

# Uses curl; adjust if you prefer something else.
# alias{mkl-download}:
# {{
#   diag "Downloading Intel oneMKL $mkl.version from $mkl.url"
#   mkdir -p $out_root
#   curl -fL -o "$mkl.archive" "$mkl.url"
# }}

# -------------------------------
# Ad-hoc recipe
# -------------------------------

# Run:
#   b mkl-install
#
# This will install:
#   $out_base/mkl/...       (includes mkl_rt.* and headers)
#   $out_base/compiler/...  (OpenMP runtime used by MKL when intel_thread is enabled)
# source redist.build
# define [see_through] import: group

# ./: libs{$name}: $intf_libs import{$name}

define json: file
json{*}: extension = json

./: json{$name-manifest}: $src_root/manifest manifest.json
json{$name-manifest}:
{{
  n        = $name($>)
  manifest = ($<[0])
  redist   = ($<[1])
  package_infix  = ($cc.target.class == 'windows' ? 'win' : 'lin')

  # 'b dist' may cap width, so join escaped lines.
  cat $path($manifest) \
    | set m [strings]
  m = $regex.apply($m, '\\\n', '')

  cat $path($manifest) \
    | sed -n -e 's/^name:\s*(.+)$/\1/p' \
    | set comp [string]

  cat $path($manifest) \
    | sed -n -e 's/^upstream-version:\s*(.*).*$/\1/p' \
    | set version_full [string]
  version_url  = $string.replace($version_full, '+', '%2B')

  json       = [json] $json.load($path($redist))
  base_url   = [string] ($json["baseUrl"])
  comp       = [json] ($json["$comp"])
  comp       = [json] ($comp["$cc.target.class"])
  subdir     = [string] ($comp["subdir"])
  basename   = [string] ($comp["basename"])
  ver_suffix = [string] ($comp["verSuffix"])
  extension  = [string] ($comp["extension"])
  manifest_url = \
    [path] "$(base_url)/$(subdir)/$(basename)$(ver_suffix)$(version_url).$(extension)"

  depdb hash $json
  diag curl $manifest_url -> $>

  curl -\# --fail --output $path($>) "$manifest_url"
}}

./: json{intel.oneapi.win.mkl.devel...}
json{intel.oneapi.win.mkl.devel...}: json{$name-manifest}
{{
  n        = $name($>[0])
  json     = ($<[0])
  json     = [json] $json.load($path($json))
  packages = [json_array] ($json["packages"])
  depdb hash $json
  diag curl $>

  res = [json_array]
  for p : $packages
    id = ($p["id"])
    if($id == $n)
      for j : ($p["payloads"])
        file = ($j["fileName"])
        url = [path] ($j["url"])
        if($string.ends_with($file, 'manifest.json'))
          curl -\# --fail --output $path($>) "$url"
          exit 0
        end
      end
    end
  end
  echo "Failed to find id '$n' with payload file 'manifest.json' in json:$\n$json.serialize($packages)" >&2
  exit 1
}}

define archive: file
archive{*}: extension = tar

./: archive{$name-$(mkl.version_full)-intel.oneapi.win.mkl.devel...}
archive{$name-$(mkl.version_full)-intel.oneapi.win.mkl.devel...}: json{intel.oneapi.win.mkl.devel...}
{{
  tar  = [path] $out_root/$leaf($path($>))
  part = [path] $(tar).part

  # extract details from redist.json
  json     = ($<[0])
  meta     = [json] $json.load($path($json))
  payloads = [json_array] ($meta["payloads"])

  for p : [json_array] $payloads
    file = [string] ($p["fileName"])
    if ($file == 'cupPayload.cup')
      url = [path] ($p["url"])
    end
  end

  depdb hash $meta
  diag curl $url -> $path($>)

  # download if missing or broken
  bsdtar -tf $tar >- 2>&1 || \
    curl -\# --fail --output $part "$url"
  test -f $part && \
    rm -f $tar && mv $part $tar &!$tar || true
  test -f $path($>) || \
    ln --symbolic $tar $path($>)
  touch $path($>)
}}

# extract{packages}: json{packages}
# {{
#   o = $posix_representation($directory($>[0]))
#   a = $posix_representation($path($<[0]))
#   d = "$(a).files"
# bsdtar -xf ./windows-x86_64-0.1.0-a.0.20251114115906-archive.exe -C ./derp --include "*packages/intel.oneapi.win*mkl*" --strip-components=1
#   pattern = [cmdline] \
#     --include "*packages/intel.oneapi.win*mkl*"

#   # extract paths for all relevant files
#   depdb dyndep \
#     --dyn-target \
#     --target-cwd "$o" \
#     --target-what 'fetched binaries' \
#     --target-default-type 'file' \
#     --target-extension-type '=file' \
#     --target-extension-type 'h=file' \
#     --target-extension-type 'hpp=file' \
#     --target-extension-type 'cuh=file' \
#     --target-extension-type 'inl=file' \
#     --target-extension-type 'a=file' \
#     --target-extension-type 'so=file' \
#     --target-extension-type 'dylib=file' \
#     --target-extension-type 'dll=file' \
#     --target-extension-type 'lib=file' \
#     --target-extension-type 'exe=file' \
#     --format lines \
#     --file "$d" \
#     -- \
#       bsdtar --fast-read -tf "$a" $pattern \
#       | sed -n -e 's%^.*?/%%p' \
#       | sed -n -e 's%^(.*)/?$%\1%p' \
#       | sed -e "s%.+/\$%$d%g" >$d

#   # extract all files
#   diag bsdtar $< $filter_out($>, group)

#   bsdtar -C "$o" -xmf "$a" --strip-components=1 $pattern
#   touch $d
# }}

# archive{$cc.target.class-$cc.target.cpu-$version-archive.tar}: redist{lib$name}
# extract{archive}: archive{$cc.target.class-$cc.target.cpu-$version-archive.tar}
# import{$name}: extract{archive}: update = match

# ./: file{hello}
# file{hello}:
# {{
#   cmd = [cmdline] $mkl.install_prog $mkl.install_args
#   diag install $>
#   echo $cmd
#   $cmd
# }}

lib{oneapi-mkl}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs

# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

#obja{*}: cxx.poptions += -DMKL_STATIC_BUILD
#objs{*}: cxx.poptions += -DMKL_SHARED_BUILD

# Export options.
#
lib{oneapi-mkl}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $intf_libs
}

#liba{oneapi-mkl}: cxx.export.poptions += -DMKL_STATIC
#libs{oneapi-mkl}: cxx.export.poptions += -DMKL_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{oneapi-mkl}: bin.lib.version = "-$version.project_id"
else
  lib{oneapi-mkl}: bin.lib.version = "-$version.major.$version.minor"

# Install into the mkl/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/mkl/
  install.subdirs = true
}
