intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

define [see_through] import: group

name = $string.replace($project, 'liboneapi-', '')

source redist.build

json{$name-manifest}: $src_root/manifest manifest.json
json{mkl.devel...}: json{$name-manifest}
json{mkl.runtime...}: json{$name-manifest}

package_infix  = ($cc.target.class == 'windows' ? 'win' : 'lin')

archive{$name-intel.oneapi.mkl.devel...}: json{mkl.devel...}
archive{$name-intel.oneapi.mkl.runtime...}: json{mkl.runtime...}
extract{$name-devel}: archive{$name-intel.oneapi.mkl.devel...}
extract{$name-runtime}: archive{$name-intel.oneapi.mkl.runtime...}

import{$name-headers}: extract{$name-devel}: update = match
import{$name-legals}: extract{$name-runtime}: update = match

import{$name-headers}:
{{
  o = $directory($>[0])
  d = $o/$name($>[0]).files

  hdrs = [paths]
  for g : $filter($<, group)
    if test -d $o/$name($g)/include
      find "$o/$name($g)/include" -type f -name "*.h*" \
        | set -n f [paths]
      hdrs += $f
    end
  end

  depdb dyndep \
    --dyn-target \
    --target-cwd "$o" \
    --target-what 'imported headers' \
    --target-extension-type 'h=h' \
    --target-extension-type 'hpp=hxx' \
    --format lines \
    --file $d \
    -- \
      echo $regex.merge($hdrs, '(.+)', '\1\n') >$d

  diag import $>

  for t : $filter_out($>, group)
    touch $path($t)
  end
}}

import{$name-legals}:
{{
  o = $directory($>[0])
  d = $o/$name($>[0]).files

  files = [paths]
  for g : $filter($<, group)
    if test -d $o/$name($g)/share/doc/$name/licensing
      find "$o/$name($g)/share/doc/$name/licensing" -type f -name "*" \
        | set -n f [paths]
      files += $f
    end
  end

  depdb dyndep \
    --dyn-target \
    --target-cwd "$o" \
    --target-what 'imported legals' \
    --target-default-type 'legal' \
    --target-extension-type '=legal' \
    --format lines \
    --file $d \
    -- \
      echo $regex.merge($files, '(.+)', '\1\n') >$d

  diag import $>

  for t : $filter_out($>, group)
    touch $path($t)
  end
}}

if ($cc.target.class == 'windows')
  libs_dir = [dir_path] $out_base/mkl-runtime/bin
else
  libs_dir = [dir_path] $out_base/mkl-runtime/lib
libi_dir = [dir_path] $out_base/mkl-devel/lib
pub_hdrs = [strings] "-I$out_base/mkl-devel/include" "-I$out_base/mkl-devel/include/oneapi"

json = [json_object] $json.load($src_base/package.json)
for m: [json_object] ($json["$cc.target.cpu-$cc.target.class"])
{
  n = $member_name($m)
  v = $member_value($m)
  libs = [paths]
  libi = [paths]
  for x: [json_array] ($v["libs"])
  {
    libs += [paths] $x
  }
  for x: [json_array] ($v["libi"])
  {
    libi += [paths] $x
  }

  # The "bundles" are either both shared & import libs (Windows),
  # or shared-only (implicitly loaded, just needs to respect RPATH).
  #
  libs{$n}: import{$name-legals} import{$name-headers}
  if (!$empty($libs) && !$empty($libi))
  {
    libs{$n}: $libs_dir/libs{$libs}: extract{$name-devel} extract{$name-runtime}
    <$libs_dir/libs{$libs} $libi_dir/libi{$libi}>: extract{$name-devel} extract{$name-runtime}

    # Export options.
    #
    libs{$n}:
    {
      cc.export.libs = $libs_dir/libs{$libs}
      cc.export.poptions = $pub_hdrs
    }
  }
  elif (!$empty($libs))
  {
    libs{$n}: $libs_dir/libs{$libs}: extract{$name-devel} extract{$name-runtime}

    # Export options.
    #
    if ($cc.target.class != 'windows')
    {
      cc.libs += -lpthread -lm -ldl
      libs{$n}:
      {
        cc.export.libs = $libs_dir/libs{$libs} -lpthread -lm -ldl
        cc.export.poptions = $pub_hdrs
      }
    }
  }
  else
  {
    fail "libs{$n}: No shared library specified. See '$src_base/packages.json'."
  }

  # For pre-releases use the complete version to make sure they cannot
  # be used in place of another pre-release or the final version. See
  # the version module for details on the version.* variable values.
  #
  if $version.pre_release
    lib{$name}: bin.lib.version = "-$version.project_id"
  else
    lib{$name}: bin.lib.version = "-$version.major.$version.minor"
}

libs{mkl-dispatch}: libs{mkl-thread-seq}
{
  cc.export.libs += libs{mkl-thread-seq}
}
libs{mkl-core}: libs{mkl-dispatch}
{
  cc.export.libs += libs{mkl-dispatch}
}
libs{mkl-thread-intel}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
# libs{mkl-thread-seq}: libs{mkl-core}
# {
#   cc.export.libs += libs{mkl-core}
# }
libs{mkl-thread-openmp}: libs{mkl-core}: include = ($cc.target.class == 'linux')
libs{mkl-thread-openmp}:
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-thread-tbb}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-lp64}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-ilp64}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-sycl}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-cluster-core}: libs{mkl-core}
{
  cc.export.libs += libs{mkl-core}
}
libs{mkl-cluster-lp64}: libs{mkl-cluster-core}
{
  cc.export.libs += libs{mkl-cluster-core}
}
libs{mkl-cluster-lp64}: libs{mkl-lp64}
{
  cc.export.libs += libs{mkl-lp64}
}
libs{mkl-cluster-ilp64}: libs{mkl-cluster-core}
{
  cc.export.libs += libs{mkl-cluster-core}
}
libs{mkl-cluster-ilp64}: libs{mkl-ilp64}
{
  cc.export.libs += libs{mkl-ilp64}
}

# Install into the mkl/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/mkl/
  install.subdirs = true
}
