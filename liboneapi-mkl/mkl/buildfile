intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

define [see_through] import: group

name = $string.replace($project, 'liboneapi-', '')

source redist.build

json{$name-manifest}: $src_root/manifest manifest.json
json{mkl.devel...}: json{$name-manifest}
json{mkl.runtime...}: json{$name-manifest}

package_infix  = ($cc.target.class == 'windows' ? 'win' : 'lin')

archive{$name-intel.oneapi.mkl.devel...}: json{mkl.devel...}
archive{$name-intel.oneapi.mkl.runtime...}: json{mkl.runtime...}
extract{$name-devel}: archive{$name-intel.oneapi.mkl.devel...}
extract{$name-runtime}: archive{$name-intel.oneapi.mkl.runtime...}

import{$name-headers}: extract{$name-devel} extract{$name-runtime}: update = match
import{$name-headers}:
{{
  o = $directory($>[0])
  d = $o/$name($>[0]).files

  hdrs = [paths]
  for g : $filter($<, group)
    if test -d $o/$name($g)/include
      find "$o/$name($g)/include" -type f -name "*.h*" \
        | set -n f [paths]
      hdrs += $f
    end
  end

  depdb dyndep \
    --dyn-target \
    --target-cwd "$o" \
    --target-what 'imported headers' \
    --target-extension-type 'h=h' \
    --target-extension-type 'hpp=hxx' \
    --format lines \
    --file $d \
    -- \
      echo $regex.merge($hdrs, '(.+)', '\1\n') >$d

  diag import $>

  for t : $filter_out($>, group)
    touch $path($t)
  end
}}

libs_dir = [dir_path] $out_base/mkl-runtime/bin
libi_dir = [dir_path] $out_base/mkl-devel/lib
pub_hdrs = [strings] "-I$out_base/mkl-devel/include" "-I$out_base/mkl-devel/include/oneapi"

json = [json_object] $json.load($src_base/package.json)
for m: [json_object] ($json["$cxx.target.cpu-$cxx.target.class"])
{
  n = $member_name($m)
  v = $member_value($m)
  libs = [paths]
  libi = [paths]
  for x: [json_array] ($v["libs"])
  {
    libs += [paths] $x
  }
  for x: [json_array] ($v["libi"])
  {
    libi += [paths] $x
  }

  # The "bundles" are either both shared & import libs (Windows),
  # or shared-only (implicitly loaded, just needs to respect RPATH).
  #
  libs{$n}: import{$name-headers}
  if (!$empty($libs) && !$empty($libi))
  {
    libs{$n}: $libs_dir/libs{$libs}: extract{$name-devel} extract{$name-runtime}
    <$libs_dir/libs{$libs} $libi_dir/libi{$libi}>: extract{$name-devel} extract{$name-runtime}

    # Export options.
    #
    libs{$n}:
    {
      cc.export.libs = $libs_dir/libs{$libs}
      cc.export.poptions = $pub_hdrs
    }
  }
  elif (!$empty($libs))
  {
    libs{$n}: $libs_dir/libs{$libs}: extract{$name-devel} extract{$name-runtime}
  }
  else
  {
    fail "libs{$n}: No shared library specified. See '$src_base/packages.json'."
  }

  # For pre-releases use the complete version to make sure they cannot
  # be used in place of another pre-release or the final version. See
  # the version module for details on the version.* variable values.
  #
  if $version.pre_release
    lib{$name}: bin.lib.version = "-$version.project_id"
  else
    lib{$name}: bin.lib.version = "-$version.major.$version.minor"
}

# Install into the mkl/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/mkl/
  install.subdirs = true
}
